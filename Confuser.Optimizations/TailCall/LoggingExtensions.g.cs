//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Änderungen an dieser Datei können falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Confuser.Optimizations.TailCall {
	
	
	[System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "11.0.0.0")]
	internal static class LoggingExtensions {
		
		private static System.Action<Microsoft.Extensions.Logging.ILogger, dnlib.DotNet.IMethod, System.Exception> _scanningForTailCall = Microsoft.Extensions.Logging.LoggerMessage.Define<dnlib.DotNet.IMethod>(Microsoft.Extensions.Logging.LogLevel.Trace, new Microsoft.Extensions.Logging.EventId(20101, "opti-101"), "Inspecting {method} for tail calls.");
		
		private static System.Action<Microsoft.Extensions.Logging.ILogger, dnlib.DotNet.IMethod, FormatHelper0, System.Exception> _foundTailCallInMethod = Microsoft.Extensions.Logging.LoggerMessage.Define<dnlib.DotNet.IMethod, FormatHelper0>(Microsoft.Extensions.Logging.LogLevel.Debug, new Microsoft.Extensions.Logging.EventId(20102, "opti-102"), "Found tail call in {method} at instruction IL_{instruction:X4}");
		
		private static System.Action<Microsoft.Extensions.Logging.ILogger, int, System.Exception> _totalInjectedTailCalls = Microsoft.Extensions.Logging.LoggerMessage.Define<int>(Microsoft.Extensions.Logging.LogLevel.Information, new Microsoft.Extensions.Logging.EventId(20103, "opti-103"), "Optimized {count} tail calls.");
		
		private static System.Action<Microsoft.Extensions.Logging.ILogger, dnlib.DotNet.IMethod, System.Exception> _scanningForTailRecursion = Microsoft.Extensions.Logging.LoggerMessage.Define<dnlib.DotNet.IMethod>(Microsoft.Extensions.Logging.LogLevel.Trace, new Microsoft.Extensions.Logging.EventId(20104, "opti-104"), "Inspecting {method} for tail recursions.");
		
		private static System.Action<Microsoft.Extensions.Logging.ILogger, dnlib.DotNet.IMethod, FormatHelper0, System.Exception> _foundTailRecursionInMethod = Microsoft.Extensions.Logging.LoggerMessage.Define<dnlib.DotNet.IMethod, FormatHelper0>(Microsoft.Extensions.Logging.LogLevel.Debug, new Microsoft.Extensions.Logging.EventId(20105, "opti-105"), "Found tail recursion in {method} at instruction IL_{instruction:X4}");
		
		private static System.Action<Microsoft.Extensions.Logging.ILogger, int, System.Exception> _totalInjectedTailRecursions = Microsoft.Extensions.Logging.LoggerMessage.Define<int>(Microsoft.Extensions.Logging.LogLevel.Information, new Microsoft.Extensions.Logging.EventId(20106, "opti-106"), "Optimized {count} tail recursions.");
		
		private static System.Func<Microsoft.Extensions.Logging.ILogger, dnlib.DotNet.IMethod, System.IDisposable> _tailCalls = Microsoft.Extensions.Logging.LoggerMessage.DefineScope<dnlib.DotNet.IMethod>("Adding tail calls: {Method}");
		
		private static System.Func<Microsoft.Extensions.Logging.ILogger, dnlib.DotNet.IMethod, System.IDisposable> _optimizeRecursion = Microsoft.Extensions.Logging.LoggerMessage.DefineScope<dnlib.DotNet.IMethod>("Optimizing recursion calls: {Method}");
		
		/// <summary>
		/// Show the following Trace log entry:
		/// <br/>
		/// Inspecting {method} for tail calls.
		/// </summary>
		/// <exception cref="System.ArgumentNullException"><paramref name="logger"/> is <see langword="null"/></exception>
		/// <remarks>
		/// Log Event ID: <c>opti-101</c>
		/// </remarks>
		internal static void LogMsgScanningForTailCall(this Microsoft.Extensions.Logging.ILogger logger, dnlib.DotNet.IMethod method) {
			if ((logger == null)) {
				throw new System.ArgumentNullException("logger");
			}
			_scanningForTailCall.Invoke(logger, method, null);
		}
		
		/// <summary>
		/// Show the following Debug log entry:
		/// <br/>
		/// Found tail call in {method} at instruction IL_{instruction:X4}
		/// </summary>
		/// <exception cref="System.ArgumentNullException"><paramref name="logger"/> is <see langword="null"/></exception>
		/// <remarks>
		/// Log Event ID: <c>opti-102</c>
		/// </remarks>
		internal static void LogMsgFoundTailCallInMethod(this Microsoft.Extensions.Logging.ILogger logger, dnlib.DotNet.IMethod method, dnlib.DotNet.Emit.Instruction instruction) {
			if ((logger == null)) {
				throw new System.ArgumentNullException("logger");
			}
			FormatHelper0 instructionFormatter = new FormatHelper0();
			instructionFormatter._sourceValue = instruction;
			_foundTailCallInMethod.Invoke(logger, method, instructionFormatter, null);
		}
		
		/// <summary>
		/// Show the following Information log entry:
		/// <br/>
		/// Optimized {count} tail calls.
		/// </summary>
		/// <exception cref="System.ArgumentNullException"><paramref name="logger"/> is <see langword="null"/></exception>
		/// <remarks>
		/// Log Event ID: <c>opti-103</c>
		/// </remarks>
		internal static void LogMsgTotalInjectedTailCalls(this Microsoft.Extensions.Logging.ILogger logger, int count) {
			if ((logger == null)) {
				throw new System.ArgumentNullException("logger");
			}
			_totalInjectedTailCalls.Invoke(logger, count, null);
		}
		
		/// <summary>
		/// Show the following Trace log entry:
		/// <br/>
		/// Inspecting {method} for tail recursions.
		/// </summary>
		/// <exception cref="System.ArgumentNullException"><paramref name="logger"/> is <see langword="null"/></exception>
		/// <remarks>
		/// Log Event ID: <c>opti-104</c>
		/// </remarks>
		internal static void LogMsgScanningForTailRecursion(this Microsoft.Extensions.Logging.ILogger logger, dnlib.DotNet.IMethod method) {
			if ((logger == null)) {
				throw new System.ArgumentNullException("logger");
			}
			_scanningForTailRecursion.Invoke(logger, method, null);
		}
		
		/// <summary>
		/// Show the following Debug log entry:
		/// <br/>
		/// Found tail recursion in {method} at instruction IL_{instruction:X4}
		/// </summary>
		/// <exception cref="System.ArgumentNullException"><paramref name="logger"/> is <see langword="null"/></exception>
		/// <remarks>
		/// Log Event ID: <c>opti-105</c>
		/// </remarks>
		internal static void LogMsgFoundTailRecursionInMethod(this Microsoft.Extensions.Logging.ILogger logger, dnlib.DotNet.IMethod method, dnlib.DotNet.Emit.Instruction instruction) {
			if ((logger == null)) {
				throw new System.ArgumentNullException("logger");
			}
			FormatHelper0 instructionFormatter = new FormatHelper0();
			instructionFormatter._sourceValue = instruction;
			_foundTailRecursionInMethod.Invoke(logger, method, instructionFormatter, null);
		}
		
		/// <summary>
		/// Show the following Information log entry:
		/// <br/>
		/// Optimized {count} tail recursions.
		/// </summary>
		/// <exception cref="System.ArgumentNullException"><paramref name="logger"/> is <see langword="null"/></exception>
		/// <remarks>
		/// Log Event ID: <c>opti-106</c>
		/// </remarks>
		internal static void LogMsgTotalInjectedTailRecursions(this Microsoft.Extensions.Logging.ILogger logger, int count) {
			if ((logger == null)) {
				throw new System.ArgumentNullException("logger");
			}
			_totalInjectedTailRecursions.Invoke(logger, count, null);
		}
		
		/// <summary>
		/// Begin the scope with the following description:
		/// <br/>
		/// Adding tail calls: {Method}
		/// </summary>
		/// <returns>
		/// A <see cref="System.IDisposable" /> that causes the scope to be closed, once <see cref="System.IDisposable.Dispose()" /> is called.
		/// </returns>
		/// <exception cref="System.ArgumentNullException"><paramref name="logger"/> is <see langword="null"/></exception>
		internal static System.IDisposable LogBeginTailCallsScope(this Microsoft.Extensions.Logging.ILogger logger, dnlib.DotNet.IMethod Method) {
			if ((logger == null)) {
				throw new System.ArgumentNullException("logger");
			}
			return _tailCalls.Invoke(logger, Method);
		}
		
		/// <summary>
		/// Begin the scope with the following description:
		/// <br/>
		/// Optimizing recursion calls: {Method}
		/// </summary>
		/// <returns>
		/// A <see cref="System.IDisposable" /> that causes the scope to be closed, once <see cref="System.IDisposable.Dispose()" /> is called.
		/// </returns>
		/// <exception cref="System.ArgumentNullException"><paramref name="logger"/> is <see langword="null"/></exception>
		internal static System.IDisposable LogBeginOptimizeRecursionScope(this Microsoft.Extensions.Logging.ILogger logger, dnlib.DotNet.IMethod Method) {
			if ((logger == null)) {
				throw new System.ArgumentNullException("logger");
			}
			return _optimizeRecursion.Invoke(logger, Method);
		}
		
		private struct FormatHelper0 : System.IFormattable {
			
			internal dnlib.DotNet.Emit.Instruction _sourceValue;
			
			public string ToString(string format, System.IFormatProvider formatProvider) {
				object resultObj = this._sourceValue.Offset;
				if ((resultObj is System.IFormattable)) {
					return ((System.IFormattable)(resultObj)).ToString(format, formatProvider);
				}
				else {
					return resultObj.ToString();
				}
			}
			
			public override string ToString() {
				return this.ToString(null, null);
			}
		}
	}
}
